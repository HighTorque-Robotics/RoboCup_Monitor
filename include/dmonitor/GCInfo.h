// Generated by gencpp from file dmsgs/GCInfo.msg
// DO NOT EDIT!


#ifndef DMSGS_MESSAGE_GCINFO_H
#define DMSGS_MESSAGE_GCINFO_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace dmsgs
{
template <class ContainerAllocator>
struct GCInfo_
{
  typedef GCInfo_<ContainerAllocator> Type;

  GCInfo_()
    : connected(false)
    , gameType(0)
    , state(0)
    , firstHalf(false)
    , kickoff(false)
    , secondaryState(0)
    , secsRemaining(0)
    , secondaryTime(0)
    , ourIndirectFreeKick(false)
    , ourDirectFreeKick(false)
    , ourPenaltyKick(false)
    , ourCornerKick(false)
    , ourGoalKick(false)
    , ourThrowIn(false)
    , enemyIndirectFreeKick(false)
    , enemyDirectFreeKick(false)
    , enemyPenaltyKick(false)
    , enemyCornerKick(false)
    , enemyGoalKick(false)
    , enemyThrowIn(false)
    , state2Ready(false)
    , state2Freeze(false)
    , penalised(false)
    , secsTillUnpenalised(0)
    , teamCyan(false)
    , ourScore(0)
    , enemyScore(0)  {
    }
  GCInfo_(const ContainerAllocator& _alloc)
    : connected(false)
    , gameType(0)
    , state(0)
    , firstHalf(false)
    , kickoff(false)
    , secondaryState(0)
    , secsRemaining(0)
    , secondaryTime(0)
    , ourIndirectFreeKick(false)
    , ourDirectFreeKick(false)
    , ourPenaltyKick(false)
    , ourCornerKick(false)
    , ourGoalKick(false)
    , ourThrowIn(false)
    , enemyIndirectFreeKick(false)
    , enemyDirectFreeKick(false)
    , enemyPenaltyKick(false)
    , enemyCornerKick(false)
    , enemyGoalKick(false)
    , enemyThrowIn(false)
    , state2Ready(false)
    , state2Freeze(false)
    , penalised(false)
    , secsTillUnpenalised(0)
    , teamCyan(false)
    , ourScore(0)
    , enemyScore(0)  {
  (void)_alloc;
    }



   typedef uint8_t _connected_type;
  _connected_type connected;

   typedef uint8_t _gameType_type;
  _gameType_type gameType;

   typedef uint8_t _state_type;
  _state_type state;

   typedef uint8_t _firstHalf_type;
  _firstHalf_type firstHalf;

   typedef uint8_t _kickoff_type;
  _kickoff_type kickoff;

   typedef uint8_t _secondaryState_type;
  _secondaryState_type secondaryState;

   typedef uint16_t _secsRemaining_type;
  _secsRemaining_type secsRemaining;

   typedef uint16_t _secondaryTime_type;
  _secondaryTime_type secondaryTime;

   typedef uint8_t _ourIndirectFreeKick_type;
  _ourIndirectFreeKick_type ourIndirectFreeKick;

   typedef uint8_t _ourDirectFreeKick_type;
  _ourDirectFreeKick_type ourDirectFreeKick;

   typedef uint8_t _ourPenaltyKick_type;
  _ourPenaltyKick_type ourPenaltyKick;

   typedef uint8_t _ourCornerKick_type;
  _ourCornerKick_type ourCornerKick;

   typedef uint8_t _ourGoalKick_type;
  _ourGoalKick_type ourGoalKick;

   typedef uint8_t _ourThrowIn_type;
  _ourThrowIn_type ourThrowIn;

   typedef uint8_t _enemyIndirectFreeKick_type;
  _enemyIndirectFreeKick_type enemyIndirectFreeKick;

   typedef uint8_t _enemyDirectFreeKick_type;
  _enemyDirectFreeKick_type enemyDirectFreeKick;

   typedef uint8_t _enemyPenaltyKick_type;
  _enemyPenaltyKick_type enemyPenaltyKick;

   typedef uint8_t _enemyCornerKick_type;
  _enemyCornerKick_type enemyCornerKick;

   typedef uint8_t _enemyGoalKick_type;
  _enemyGoalKick_type enemyGoalKick;

   typedef uint8_t _enemyThrowIn_type;
  _enemyThrowIn_type enemyThrowIn;

   typedef uint8_t _state2Ready_type;
  _state2Ready_type state2Ready;

   typedef uint8_t _state2Freeze_type;
  _state2Freeze_type state2Freeze;

   typedef uint8_t _penalised_type;
  _penalised_type penalised;

   typedef uint8_t _secsTillUnpenalised_type;
  _secsTillUnpenalised_type secsTillUnpenalised;

   typedef uint8_t _teamCyan_type;
  _teamCyan_type teamCyan;

   typedef uint8_t _ourScore_type;
  _ourScore_type ourScore;

   typedef uint8_t _enemyScore_type;
  _enemyScore_type enemyScore;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(STATE_INITIAL)
  #undef STATE_INITIAL
#endif
#if defined(_WIN32) && defined(STATE_READY)
  #undef STATE_READY
#endif
#if defined(_WIN32) && defined(STATE_SET)
  #undef STATE_SET
#endif
#if defined(_WIN32) && defined(STATE_PLAYING)
  #undef STATE_PLAYING
#endif
#if defined(_WIN32) && defined(STATE_FINISHED)
  #undef STATE_FINISHED
#endif
#if defined(_WIN32) && defined(STATE2_NORMAL)
  #undef STATE2_NORMAL
#endif
#if defined(_WIN32) && defined(STATE2_PENALTYSHOOT)
  #undef STATE2_PENALTYSHOOT
#endif
#if defined(_WIN32) && defined(STATE2_OVERTIME)
  #undef STATE2_OVERTIME
#endif
#if defined(_WIN32) && defined(STATE2_TIMEOUT)
  #undef STATE2_TIMEOUT
#endif
#if defined(_WIN32) && defined(STATE2_DIRECT_FREEKICK)
  #undef STATE2_DIRECT_FREEKICK
#endif
#if defined(_WIN32) && defined(STATE2_INDIRECT_FREEKICK)
  #undef STATE2_INDIRECT_FREEKICK
#endif
#if defined(_WIN32) && defined(STATE2_PENALTYKICK)
  #undef STATE2_PENALTYKICK
#endif
#if defined(_WIN32) && defined(STATE2_CORNER_KICK)
  #undef STATE2_CORNER_KICK
#endif
#if defined(_WIN32) && defined(STATE2_GOAL_KICK)
  #undef STATE2_GOAL_KICK
#endif
#if defined(_WIN32) && defined(STATE2_THROW_IN)
  #undef STATE2_THROW_IN
#endif

  enum {
    STATE_INITIAL = 0u,
    STATE_READY = 1u,
    STATE_SET = 2u,
    STATE_PLAYING = 3u,
    STATE_FINISHED = 4u,
    STATE2_NORMAL = 0u,
    STATE2_PENALTYSHOOT = 1u,
    STATE2_OVERTIME = 2u,
    STATE2_TIMEOUT = 3u,
    STATE2_DIRECT_FREEKICK = 4u,
    STATE2_INDIRECT_FREEKICK = 5u,
    STATE2_PENALTYKICK = 6u,
    STATE2_CORNER_KICK = 7u,
    STATE2_GOAL_KICK = 8u,
    STATE2_THROW_IN = 9u,
  };


  typedef boost::shared_ptr< ::dmsgs::GCInfo_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::dmsgs::GCInfo_<ContainerAllocator> const> ConstPtr;

}; // struct GCInfo_

typedef ::dmsgs::GCInfo_<std::allocator<void> > GCInfo;

typedef boost::shared_ptr< ::dmsgs::GCInfo > GCInfoPtr;
typedef boost::shared_ptr< ::dmsgs::GCInfo const> GCInfoConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::dmsgs::GCInfo_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::dmsgs::GCInfo_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::dmsgs::GCInfo_<ContainerAllocator1> & lhs, const ::dmsgs::GCInfo_<ContainerAllocator2> & rhs)
{
  return lhs.connected == rhs.connected &&
    lhs.gameType == rhs.gameType &&
    lhs.state == rhs.state &&
    lhs.firstHalf == rhs.firstHalf &&
    lhs.kickoff == rhs.kickoff &&
    lhs.secondaryState == rhs.secondaryState &&
    lhs.secsRemaining == rhs.secsRemaining &&
    lhs.secondaryTime == rhs.secondaryTime &&
    lhs.ourIndirectFreeKick == rhs.ourIndirectFreeKick &&
    lhs.ourDirectFreeKick == rhs.ourDirectFreeKick &&
    lhs.ourPenaltyKick == rhs.ourPenaltyKick &&
    lhs.ourCornerKick == rhs.ourCornerKick &&
    lhs.ourGoalKick == rhs.ourGoalKick &&
    lhs.ourThrowIn == rhs.ourThrowIn &&
    lhs.enemyIndirectFreeKick == rhs.enemyIndirectFreeKick &&
    lhs.enemyDirectFreeKick == rhs.enemyDirectFreeKick &&
    lhs.enemyPenaltyKick == rhs.enemyPenaltyKick &&
    lhs.enemyCornerKick == rhs.enemyCornerKick &&
    lhs.enemyGoalKick == rhs.enemyGoalKick &&
    lhs.enemyThrowIn == rhs.enemyThrowIn &&
    lhs.state2Ready == rhs.state2Ready &&
    lhs.state2Freeze == rhs.state2Freeze &&
    lhs.penalised == rhs.penalised &&
    lhs.secsTillUnpenalised == rhs.secsTillUnpenalised &&
    lhs.teamCyan == rhs.teamCyan &&
    lhs.ourScore == rhs.ourScore &&
    lhs.enemyScore == rhs.enemyScore;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::dmsgs::GCInfo_<ContainerAllocator1> & lhs, const ::dmsgs::GCInfo_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace dmsgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::dmsgs::GCInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::dmsgs::GCInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::dmsgs::GCInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::dmsgs::GCInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::dmsgs::GCInfo_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::dmsgs::GCInfo_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::dmsgs::GCInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "b3e92dff4dc6cd35153ee29d3221f4cb";
  }

  static const char* value(const ::dmsgs::GCInfo_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xb3e92dff4dc6cd35ULL;
  static const uint64_t static_value2 = 0x153ee29d3221f4cbULL;
};

template<class ContainerAllocator>
struct DataType< ::dmsgs::GCInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "dmsgs/GCInfo";
  }

  static const char* value(const ::dmsgs::GCInfo_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::dmsgs::GCInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# General\n"
"bool connected\n"
"\n"
"# Control Data\n"
"uint8 gameType\n"
"uint8 state\n"
"bool firstHalf\n"
"bool kickoff\n"
"uint8 secondaryState\n"
"uint16 secsRemaining\n"
"uint16 secondaryTime\n"
"\n"
"bool ourIndirectFreeKick\n"
"bool ourDirectFreeKick\n"
"bool ourPenaltyKick\n"
"bool ourCornerKick\n"
"bool ourGoalKick\n"
"bool ourThrowIn\n"
"\n"
"bool enemyIndirectFreeKick\n"
"bool enemyDirectFreeKick\n"
"bool enemyPenaltyKick\n"
"bool enemyCornerKick\n"
"bool enemyGoalKick\n"
"bool enemyThrowIn\n"
"\n"
"bool state2Ready\n"
"bool state2Freeze\n"
"\n"
"# Robot Info\n"
"bool penalised\n"
"uint8 secsTillUnpenalised\n"
"\n"
"# Team Info\n"
"bool teamCyan\n"
"uint8 ourScore\n"
"uint8 enemyScore\n"
"\n"
"# STATE\n"
"uint8 STATE_INITIAL            =  0\n"
"uint8 STATE_READY              =  1\n"
"uint8 STATE_SET                =  2\n"
"uint8 STATE_PLAYING            =  3\n"
"uint8 STATE_FINISHED           =  4\n"
"\n"
"# STATE2\n"
"uint8 STATE2_NORMAL            =  0\n"
"uint8 STATE2_PENALTYSHOOT      =  1\n"
"uint8 STATE2_OVERTIME          =  2\n"
"uint8 STATE2_TIMEOUT           =  3\n"
"uint8 STATE2_DIRECT_FREEKICK   =  4\n"
"uint8 STATE2_INDIRECT_FREEKICK =  5\n"
"uint8 STATE2_PENALTYKICK       =  6\n"
"uint8 STATE2_CORNER_KICK       =  7\n"
"uint8 STATE2_GOAL_KICK         =  8\n"
"uint8 STATE2_THROW_IN          =  9\n"
;
  }

  static const char* value(const ::dmsgs::GCInfo_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::dmsgs::GCInfo_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.connected);
      stream.next(m.gameType);
      stream.next(m.state);
      stream.next(m.firstHalf);
      stream.next(m.kickoff);
      stream.next(m.secondaryState);
      stream.next(m.secsRemaining);
      stream.next(m.secondaryTime);
      stream.next(m.ourIndirectFreeKick);
      stream.next(m.ourDirectFreeKick);
      stream.next(m.ourPenaltyKick);
      stream.next(m.ourCornerKick);
      stream.next(m.ourGoalKick);
      stream.next(m.ourThrowIn);
      stream.next(m.enemyIndirectFreeKick);
      stream.next(m.enemyDirectFreeKick);
      stream.next(m.enemyPenaltyKick);
      stream.next(m.enemyCornerKick);
      stream.next(m.enemyGoalKick);
      stream.next(m.enemyThrowIn);
      stream.next(m.state2Ready);
      stream.next(m.state2Freeze);
      stream.next(m.penalised);
      stream.next(m.secsTillUnpenalised);
      stream.next(m.teamCyan);
      stream.next(m.ourScore);
      stream.next(m.enemyScore);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct GCInfo_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::dmsgs::GCInfo_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::dmsgs::GCInfo_<ContainerAllocator>& v)
  {
    s << indent << "connected: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.connected);
    s << indent << "gameType: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gameType);
    s << indent << "state: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state);
    s << indent << "firstHalf: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.firstHalf);
    s << indent << "kickoff: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.kickoff);
    s << indent << "secondaryState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secondaryState);
    s << indent << "secsRemaining: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.secsRemaining);
    s << indent << "secondaryTime: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.secondaryTime);
    s << indent << "ourIndirectFreeKick: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ourIndirectFreeKick);
    s << indent << "ourDirectFreeKick: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ourDirectFreeKick);
    s << indent << "ourPenaltyKick: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ourPenaltyKick);
    s << indent << "ourCornerKick: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ourCornerKick);
    s << indent << "ourGoalKick: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ourGoalKick);
    s << indent << "ourThrowIn: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ourThrowIn);
    s << indent << "enemyIndirectFreeKick: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.enemyIndirectFreeKick);
    s << indent << "enemyDirectFreeKick: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.enemyDirectFreeKick);
    s << indent << "enemyPenaltyKick: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.enemyPenaltyKick);
    s << indent << "enemyCornerKick: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.enemyCornerKick);
    s << indent << "enemyGoalKick: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.enemyGoalKick);
    s << indent << "enemyThrowIn: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.enemyThrowIn);
    s << indent << "state2Ready: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state2Ready);
    s << indent << "state2Freeze: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state2Freeze);
    s << indent << "penalised: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.penalised);
    s << indent << "secsTillUnpenalised: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secsTillUnpenalised);
    s << indent << "teamCyan: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.teamCyan);
    s << indent << "ourScore: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ourScore);
    s << indent << "enemyScore: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.enemyScore);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DMSGS_MESSAGE_GCINFO_H
